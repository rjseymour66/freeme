+++
title = 'Files'
date = '2025-09-06T00:01:29-04:00'
weight = 50
draft = false
+++


## Reading files

Go's `os` package provides numerous methods to read a file that depend on the use case.

### ReadFile

`ReadFile` is an easy-to-use convenience method that reads the entire file contents into memory and closes the file. It returns a byte slice and an error. This method has the following risks:
- Preallocates byte slice before reading, which can consume a lot of memory for a large file.
- You can't read as a stream and chunk the data.
- Cannot handle an EOF. It only returns errors on file operations (can't open file) or corrupted reads.
- Blocks on read, so slow disk reads pose an issue
- Malicious actor can point to large file, resulting in Denial of Service (DoS) vector

Use `ReadFile` for small and medium files:

```go
func main() {
	data, err := os.ReadFile("../logging/structured.log")
	if err != nil {
		panic(err)
	}
	log.Println(string(data))
}
```

### Open

`Open` lets you read a file in chunks and process it sequentially, which is much more efficient than loading the entire file into memory. Use `Open` with a `Scanner` or `Reader`:

```go
func lineRead(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Scanner or Reader to process
}
```

### Scanner

A [scanner](https://pkg.go.dev/bufio#Scanner) is a high-level utility that reads tokenized input. Tokenized input is data that uses a delimiter to signal the end of a data value. A scanner is memory-safe because it keeps only one token in memory.

{{< admonition "Default token size" warning >}}
A scanner has a default token size of 64KB. If you need to read larger tokens, increase the buffer size with `scanner.Buffer()`.
{{< /admonition >}}

This example reads a file with a scanner that stops at a newline:
1. Open the file.
2. Close the file.
3. Create a new scanner. Pass a file descriptor to the scanner.
4. An infinite loop with `Scan()`, a method that advances the scanner to the next token. It returns `false` when there are no more tokens or it reaches an EOF.
5. `Text()` returns the most recent token generated by `Scan()`.
6. `Err()` returns the first non-EOF error generated by `Scan()`.

```go
func lineRead(filename string) {
	file, err := os.Open(filename)          // 1
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()                      // 2

	scanner := bufio.NewScanner(file)       // 3

	for scanner.Scan() {                    // 4
		line := scanner.Text()              // 5
		fmt.Println(line)
	}

	if err := scanner.Err(); err != nil {   // 6
		log.Fatal(err)
	}
}
```

By default, the token delimiter is a newline character, but you can change that with the `Split` function. You can create a custom delimiter with [SplitFunc](https://pkg.go.dev/bufio#SplitFunc), or you can use one of the [convenience methods](https://pkg.go.dev/bufio#pkg-functions) that Go provides to read by byte, line, word, or rune.

This example reads a file and changes the scanner to read by word:

```go
func wordRead(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanWords)          // change the delimiter

	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}
```

### Reader

`Reader` gives you granular control over reads. Unlike a scanner, a `Reader` can read raw bytes and return EOFs. This is best used when parsing custom protocols.

This example reads a file line-by-line:
1. Open the file.
2. Close the file.
3. Create a new `Reader`. `NewReader` accepts a file descriptor and returns a `Reader` with an underlying buffer.
4. Create an infinte loop.
5. Use a `Reader` function to read as much data as you need. Here, we read a string and stop at a newline character.
6. Check if there was an EOF in the last read.
7. If there was an EOF, print the contents of the buffer that was read before the EOF and break from the loop.
8. Print the contents of the buffer.
   
```go
func lineRead(filename string) {
	file, err := os.Open(filename)              // 1
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()                          // 2

	reader := bufio.NewReader(file)             // 3
	for {                                       // 4
		line, err := reader.ReadString('\n')    // 5
        // word, err := reader.ReadString(' ')  
		if err == io.EOF {                      // 6
			fmt.Print(line)                     // 7
			break
		}

		if err != nil {
			log.Fatal(err)
		}
		fmt.Print(line)                         // 8
	}
}
```

#### File metadata

`Open` returns a file descriptor, and the file descriptor provides a `Stat` function that gives you access to file metadata:
1. Open the file.
2. Close the file with `defer`.
3. Get the file metadata.

```go
func main() {
	file, err := os.Open("structured.log")  // 1
	if err != nil {
		panic(err)
	}
	defer file.Close()                      // 2

	info, err := file.Stat()                // 3
	if err != nil {
		panic(err)
	}

	log.Printf("\nFile name:\t%s\nFile mode:\t%v\nFile size:\t%d\nDirectory:\t%v\n",
		info.Name(), info.Mode(), info.Size(), info.IsDir())
}
```

## Writing files

Go's `os` package provides numerous methods to read a file to support multiple use cases.

### Create

`Create` is a simple way to way to write to a file. Pass it the name of a file---if the file exists, it will open the file. If the file doesn't exist, it creates the file. It returns a file handle and an error.

This example creates a file, closes it, then writes a string to the file. This example uses `WriteString`, but you can also write bytes with `Write`:

```go
func main() {
	file, err := os.Create("test.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString("test")
}
```

### io.Copy (buffered writes)

`Create` is simple and works well, but it requires data in memory. If you want to stream data into your writes, you can use `io.Copy`.

`io.Copy(dest, src)` uses a 32KB buffer to read from the source `Reader`, and it can copy that many bytes to the destination `Writer` until until EOF. It returns the number of bytes written and an error:
1. Open the source file.
2. Close the source file.
3. Create or open the destination file
4. Close the destination file.
5. Copy from the source to the destination. You can ignore the number of bytes copied, but you should handle the error.

```go
func bufferedWrites(destination, source string) error {
	src, err := os.Open(source)             // 1
	if err != nil {
		return err
	}
	defer src.Close()                       // 2

	dest, err := os.Create(destination)     // 3
	if err != nil {
		return err
	}
	defer dest.Close()                      // 4

	_, err = io.Copy(dest, src)             // 5
	if err != nil {
		return err
	}
	return nil
}
```

### OpenFile

`OpenFile` can write to a file with flags and permissions. The flags give you options on how to open the file, and you can combine them with the bitwise OR (`|`). For example, you can append to an existing file, or create and open a file in read-only mode.

This example appends text to the file we created in the [Create](#create) code. The flags mean: open the file for writing only. If the file doesn't exist, create it. If it does exist, write to the end of the file:

```go
func main() {
	file, err := os.OpenFile("test.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	if _, err := file.WriteString("test two!"); err != nil {
		panic(err)
	}
}
```
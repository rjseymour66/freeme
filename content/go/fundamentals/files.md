+++
title = 'Files'
date = '2025-09-06T00:01:29-04:00'
weight = 50
draft = false
+++


## Reading files

Go's `os` package provides numerous methods to read a file that depend on the use case.

### ReadFile

`ReadFile` is an easy-to-use convenience method that reads the entire file contents into memory and closes the file. It returns a byte slice and an error. This method has the following risks:
- Preallocates byte slice before reading, which can consume a lot of memory for a large file.
- You can't read as a stream and chunk the data.
- Cannot handle an EOF. It only returns errors on file operations (can't open file) or corrupted reads.
- Blocks on read, so slow disk reads pose an issue
- Malicious actor can point to large file, resulting in Denial of Service (DoS) vector

Use `ReadFile` for small and medium files:

```go
func main() {
	data, err := os.ReadFile("../logging/structured.log")
	if err != nil {
		panic(err)
	}
	log.Println(string(data))
}
```

### Open

`Open` lets you read a file in chunks and process it sequentially, which is much more efficient than loading the entire file into memory. Use `Open` with a `Scanner` or `Reader`:

```go
func lineRead(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Scanner or Reader to process
}
```

### Scanner

Read tokenized input with [scanner](https://pkg.go.dev/bufio#Scanner), a high-level utility. Tokenized input is data that uses a delimiter to signal the end of a token. A scanner is memory-safe because it keeps only one token in memory.

{{< admonition "Default token size" warning >}}
A scanner has a default token size of 64KB. If you need to read larger tokens, increase the buffer size with `scanner.Buffer()`.
{{< /admonition >}}

This example reads a file with a scanner that stops at a newline:
1. Open the file.
2. Close the file.
3. Create a new scanner. Pass a file descriptor to the scanner.
4. An infinite loop with `Scan()`, a method that advances the scanner to the next token. It returns `false` when there are no more tokens or it reaches an EOF.
5. `Text()` returns the most recent token generated by `Scan()`.
6. `Err()` returns the first non-EOF error generated by `Scan()`.

```go
func lineRead(filename string) {
	file, err := os.Open(filename)          // 1
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()                      // 2

	scanner := bufio.NewScanner(file)       // 3

	for scanner.Scan() {                    // 4
		line := scanner.Text()              // 5
		fmt.Println(line)
	}

	if err := scanner.Err(); err != nil {   // 6
		log.Fatal(err)
	}
}
```

By default, the token delimiter is a newline character, but you can change that with the `Split` function. You can create a custom delimiter with [SplitFunc](https://pkg.go.dev/bufio#SplitFunc), or you can use one of the [convenience methods](https://pkg.go.dev/bufio#pkg-functions) that Go provides to read by byte, line, word, or rune.

This example reads a file and changes the scanner to read by word:

```go
func wordRead(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanWords)          // change the delimiter

	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}
```

### Reader

`Reader` gives you granular control over reads. Unlike a scanner, a `Reader` can read raw bytes and return EOFs. This is best used when parsing custom protocols.

This example reads a file line-by-line:
1. Open the file.
2. Close the file.
3. Create a new `Reader`. `NewReader` accepts a file descriptor and returns a `Reader` with an underlying buffer.
4. Create an infinte loop.
5. Use a `Reader` function to read as much data as you need. Here, we read a string and stop at a newline character.
6. Check if there was an EOF in the last read.
7. If there was an EOF, print the contents of the buffer that was read before the EOF and break from the loop.
8. Print the contents of the buffer.
   
```go
func lineRead(filename string) {
	file, err := os.Open(filename)              // 1
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()                          // 2

	reader := bufio.NewReader(file)             // 3
	for {                                       // 4
		line, err := reader.ReadString('\n')    // 5
        // word, err := reader.ReadString(' ')  
		if err == io.EOF {                      // 6
			fmt.Print(line)                     // 7
			break
		}

		if err != nil {
			log.Fatal(err)
		}
		fmt.Print(line)                         // 8
	}
}
```

#### File metadata

`Open` returns a file descriptor, and the file descriptor provides a `Stat` function that gives you access to file metadata:
1. Open the file.
2. Close the file with `defer`.
3. Get the file metadata.

```go
func main() {
	file, err := os.Open("structured.log")  // 1
	if err != nil {
		panic(err)
	}
	defer file.Close()                      // 2

	info, err := file.Stat()                // 3
	if err != nil {
		panic(err)
	}

	log.Printf("\nFile name:\t%s\nFile mode:\t%v\nFile size:\t%d\nDirectory:\t%v\n",
		info.Name(), info.Mode(), info.Size(), info.IsDir())
}
```

## Writing files